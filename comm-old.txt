/**
 *  @file
 *  Alamods communications abstraction layer - Comm
 *
 *  This module provides an API layer for communication with any/all
 *  alamods modules attached to a host (i.e. Raspberry Pi(r)) system.
 *
 *  It provides an SPI interface for alamods modules with an embedded
 *  processor (smart module) and also provides an I2C interface for
 *  for control and status of the power module (PWRM17225) gpio
 *  including the LEDs, fan power, power out, OLED switches and
 *  current monitoring
 */

/*
 *  REQUIRED NODE MODULES
 */
let util                                = require("util");
let path                                = require("path");
let fs                                  = require("fs");
let process                             = require('process');
let EventEmitter                        = require('events').EventEmitter;

let rpio                                = require('rpio');


/*
 *  LOCAL VARIABLES
 */
let gpio                                = 0;
let i2cRxBfr                            = new Buffer.alloc(8);
let i2cWrite1Bfr                        = new Buffer.from([0x00]);
let i2cWrite2Bfr                        = new Buffer.from([0x00, 0x00]);
let i2cWrite3Bfr                        = new Buffer.from([0x00, 0x00, 0x00]);
let spiTxBuf                            = Buffer.from([0x00, 0x00, 0x00, 0x00]);
let spiRxBuf                            = new Buffer(32);



/*
 *  Module Object Constructor
 */
function Comm(type) {
    EventEmitter.call(this);

    let self                            = this;

    if (type === 'M') {
        // GPIO setup
        rpio.init({gpiomem: false});
        // set the alamods module address lines to 0
        rpio.open(16, rpio.OUTPUT, rpio.HIGH);
        rpio.open(18, rpio.OUTPUT, rpio.HIGH);
        rpio.open(29, rpio.OUTPUT, rpio.HIGH);
        rpio.open(31, rpio.OUTPUT, rpio.HIGH);

    } else if (type === 'Z') {

    } else {
        throw new Error("Need a type - M or Z");
    }


}
util.inherits(Comm, EventEmitter);



/*
 *  CONSTANTS
 */
Comm.prototype.FAN_ON                   = 1;
Comm.prototype.FAN_OFF                  = 0;



/*
 * API Methods
 */


Comm.prototype.isohcmRelay0             = function(moduleAddr, state) {
    // SPI setup
    rpio.spiBegin();
    rpio.spiChipSelect(0);
    rpio.spiSetClockDivider(512);
    rpio.spiSetDataMode(0);
    // set the module address
    _moduleAddr(moduleAddr);
    // setup to read the relay control register
    spiTxBuf[0]                         = 0x01;
    spiTxBuf[1]                         = 0x10;
    spiTxBuf[2]                         = 0x00;
    spiTxBuf[3]                         = 0x00;
    rpio.spiTransfer(spiTxBuf, spiRxBuf, 4);
    // read the modules relay control register
    spiTxBuf[0]                         = 0x00;
    spiTxBuf[1]                         = 0x10;
    spiTxBuf[2]                         = 0x00;
    spiTxBuf[3]                         = 0x00;
    rpio.spiTransfer(spiTxBuf, spiRxBuf, 4);

    let relayReg                        = spiRxBuf[3] + ((spiRxBuf[2] << 8) & 0x0000ff00);

    spiTxBuf[0]                         = 0x02;
    spiTxBuf[1]                         = 0x10;
    if (state === 'ON') {
        relayReg                        = relayReg | 0x00000001;
        spiTxBuf[2]                     = ((relayReg & 0x0000ff00) >> 8);
        spiTxBuf[3]                     = (relayReg & 0x000000ff);
    } else if (state === 'OFF') {
        relayReg                        = relayReg & 0xfffffffe;
        spiTxBuf[2]                     = ((relayReg & 0x0000ff00) >> 8);
        spiTxBuf[3]                     = (relayReg & 0x000000ff);
    }

    rpio.spiTransfer(spiTxBuf, spiRxBuf, 4);
    rpio.spiEnd();
}

Comm.prototype.isohcmRelay1             = function(moduleAddr, state) {
    // SPI setup
    rpio.spiBegin();
    rpio.spiChipSelect(0);
    rpio.spiSetClockDivider(512);
    rpio.spiSetDataMode(0);
    // set the module address
    _moduleAddr(moduleAddr);
    // setup to read the relay control register
    spiTxBuf[0]                         = 0x01;
    spiTxBuf[1]                         = 0x10;
    spiTxBuf[2]                         = 0x00;
    spiTxBuf[3]                         = 0x00;
    rpio.spiTransfer(spiTxBuf, spiRxBuf, 4);
    // read the modules relay control register
    spiTxBuf[0]                         = 0x00;
    spiTxBuf[1]                         = 0x10;
    spiTxBuf[2]                         = 0x00;
    spiTxBuf[3]                         = 0x00;
    rpio.spiTransfer(spiTxBuf, spiRxBuf, 4);

    let relayReg                        = spiRxBuf[3] + ((spiRxBuf[2] << 8) & 0x0000ff00);

    spiTxBuf[0]                         = 0x02;
    spiTxBuf[1]                         = 0x10;
    if (state === 'ON') {
        relayReg                        = relayReg | 0x00000002;
        spiTxBuf[2]                     = ((relayReg & 0x0000ff00) >> 8);
        spiTxBuf[3]                     = (relayReg & 0x000000ff);
    } else if (state === 'OFF') {
        relayReg                        = relayReg & 0xfffffffd;
        spiTxBuf[2]                     = ((relayReg & 0x0000ff00) >> 8);
        spiTxBuf[3]                     = (relayReg & 0x000000ff);
    }

    rpio.spiTransfer(spiTxBuf, spiRxBuf, 4);
    rpio.spiEnd();
}

Comm.prototype.moduleRegWrite = function (moduleAddr, registerAddr, regValue) {
    // SPI setup
    rpio.spiBegin();
    rpio.spiChipSelect(0);
    rpio.spiSetClockDivider(512);
    rpio.spiSetDataMode(0);
    // set the module address
    _moduleAddr(moduleAddr);
    // setup the alamods SPI command structure and send the message
    spiTxBuf[0]                         = 0x02;
    spiTxBuf[1]                         = registerAddr;
    spiTxBuf[2]                         = ((regValue & 0x0000ff00) >> 8);
    spiTxBuf[3]                         = (regValue & 0x000000ff);
    rpio.spiTransfer(spiTxBuf, spiRxBuf, 4);

    rpio.spiEnd();
}

Comm.prototype.moduleRegRead            = function (moduleAddr, registerAddr) {
    // SPI setup
    rpio.spiBegin();
    rpio.spiChipSelect(0);
    rpio.spiSetClockDivider(512);
    rpio.spiSetDataMode(0);
    // set the module address
    _moduleAddr(moduleAddr);
    // setup the read index register within the module
    //  - byte 0    = 0x01 - is the command to set the internal read index (addr) register
    //  - byte 1    = desired module internal register index (addr) to read
    //  - byte 2/3  = any value
    spiTxBuf[0]                         = 0x01;
    spiTxBuf[1]                         = registerAddr;
    spiTxBuf[2]                         = 0x00;
    spiTxBuf[3]                         = 0x00;
    rpio.spiTransfer(spiTxBuf, spiRxBuf, 4);
    // read the specified module register
    //  - byte 0    = 0x00 - is the command to read the register pointed to by the index pointer
    //  - byte 1    = desired module internal register index (addr) to read
    //  - byte 2/3  = any value
    spiTxBuf[0]                         = 0x00;
    spiTxBuf[1]                         = registerAddr;
    spiTxBuf[2]                         = 0x00;
    spiTxBuf[3]                         = 0x00;
    rpio.spiTransfer(spiTxBuf, spiRxBuf, 4);

    rpio.spiEnd();
    // return the 16 bit value
    return(spiRxBuf[3] + ((spiRxBuf[2] << 8) & 0x0000ff00));
}

Comm.prototype.pwrmInit                 = function() {
    // shutdown button
    rpio.open(40, rpio.INPUT, rpio.PULL_UP);

    // Initialize the GPIO expander on the PWRM17225 module
    // read GPIO expander control register
    i2cWrite1Bfr[0]                     = 0x01;
    rpio.i2cWrite(i2cWrite1Bfr);
    rpio.i2cRead(i2cRxBfr, 1);
    // setup the individual port pin directions
    //  - bit 7     = input     switch 1
    //  - bit 6     = input     switch 2
    //  - bit 5     = input     fan tach
    //  - bit 4     = output    fan power control
    //  - bit 3     = output    LED grn
    //  - bit 2     = output    LED red
    //  - bit 1     = output    Power strip control
    //  - bit 0     = output    LED blu
    i2cWrite2Bfr[0]                     = 0x03;
    i2cWrite2Bfr[1]                     = 0x1f;
    rpio.i2cWrite(i2cWrite2Bfr);
    // disable the high Z state of the output pins (bits 0 - 4)
    // 0 = disable high-Z, 1 = enable high-z
    i2cWrite2Bfr[0]                     = 0x07;
    i2cWrite2Bfr[1]                     = 0x70;
    rpio.i2cWrite(i2cWrite2Bfr);
    // read GPIO expander output register
    i2cWrite1Bfr[0]                     = 0x05;
    rpio.i2cWrite(i2cWrite1Bfr);
    rpio.i2cRead(i2cRxBfr, 1);
    // change the LED pins to magenta (red & blue) only
    i2cWrite2Bfr[0]                     = 0x05;
    gpio                                = 0x05;
    i2cWrite2Bfr[1]                     = gpio;
    rpio.i2cWrite(i2cWrite2Bfr);
    rpio.i2cEnd();
}

Comm.prototype.pwrzInit                 = function() {
    rpio.open(22, rpio.OUTPUT, rpio.HIGH);
}

Comm.prototype.pwrmLedWrite             = function(red, grn, blu) {
    rpio.i2cBegin();
    rpio.i2cSetSlaveAddress(0x43);
    rpio.i2cSetBaudRate(100000);
    rpio.i2cSetClockDivider(2500);

    // read GPIO expander output register
    i2cWrite1Bfr[0]                     = 0x05;
    rpio.i2cWrite(i2cWrite1Bfr);
    rpio.i2cRead(i2cRxBfr, 1);

    gpio                                = i2cRxBfr[0];
    i2cWrite2Bfr[0]                     = 0x05;

    if (red) {
        gpio                            = (gpio | 0x04);
        i2cWrite2Bfr[1]                 = gpio;
    } else {
        gpio                            = (gpio & 0xfb);
        i2cWrite2Bfr[1]                 = gpio;
    }
    if (grn) {
        gpio                            = (gpio | 0x08);
        i2cWrite2Bfr[1]                 = gpio;
    } else {
        gpio                            = (gpio & 0xf7);
        i2cWrite2Bfr[1]                 = gpio;
    }
    if (blu) {
        gpio                            = (gpio | 0x01);
        i2cWrite2Bfr[1]                 = gpio;
    } else {
        gpio                            = (gpio & 0xfe);
        i2cWrite2Bfr[1]                 = gpio;
    }

    rpio.i2cWrite(i2cWrite2Bfr);
    rpio.i2cEnd();
}

Comm.prototype.pwrmFanPwrOff            = function() {
    rpio.i2cBegin();
    rpio.i2cSetSlaveAddress(0x43);
    rpio.i2cSetBaudRate(100000);
    rpio.i2cSetClockDivider(2500);

    // read GPIO expander output register
    i2cWrite1Bfr[0]                     = 0x05;
    rpio.i2cWrite(i2cWrite1Bfr);
    rpio.i2cRead(i2cRxBfr, 1);

    gpio                                = i2cRxBfr[0];
    gpio                                = gpio | 0xef;
    i2cWrite2Bfr[0]                     = 0x05;
    i2cWrite2Bfr[1]                     = gpio;
    rpio.i2cWrite(i2cWrite2Bfr);
    rpio.i2cEnd();
}

Comm.prototype.pwrmFanPwrOn             = function() {
    rpio.i2cBegin();
    rpio.i2cSetSlaveAddress(0x43);
    rpio.i2cSetBaudRate(100000);
    rpio.i2cSetClockDivider(2500);

    // read GPIO expander output register
    i2cWrite1Bfr[0]                     = 0x05;
    rpio.i2cWrite(i2cWrite1Bfr);
    rpio.i2cRead(i2cRxBfr, 1);

    gpio                                = i2cRxBfr[0];
    gpio                                = gpio | 0x10;
    i2cWrite2Bfr[0]                     = 0x05;
    i2cWrite2Bfr[1]                     = gpio;
    rpio.i2cWrite(i2cWrite2Bfr);
    rpio.i2cEnd();
}

Comm.prototype.pwrmPwrOutOff            = function() {
    rpio.i2cBegin();
    rpio.i2cSetSlaveAddress(0x43);
    rpio.i2cSetBaudRate(100000);
    rpio.i2cSetClockDivider(2500);

    // read GPIO expander output register
    i2cWrite1Bfr[0]                     = 0x05;
    rpio.i2cWrite(i2cWrite1Bfr);
    rpio.i2cRead(i2cRxBfr, 1);
    // modify the power out bit to turn off
    gpio                                = i2cRxBfr[0];
    gpio                                = gpio | 0xfd;
    // store new gpio value into GPIO expander output register
    i2cWrite2Bfr[0]                     = 0x05;
    i2cWrite2Bfr[1]                     = gpio;
    rpio.i2cWrite(i2cWrite2Bfr);
    rpio.i2cEnd();
}

Comm.prototype.pwrmPwrOutOn             = function() {
    rpio.i2cBegin();
    rpio.i2cSetSlaveAddress(0x43);
    rpio.i2cSetBaudRate(100000);
    rpio.i2cSetClockDivider(2500);

    // read GPIO expander output register
    i2cWrite1Bfr[0]                     = 0x05;
    rpio.i2cWrite(i2cWrite1Bfr);
    rpio.i2cRead(i2cRxBfr, 1);
    // modify the power out bit to turn on
    gpio                                = i2cRxBfr[0];
    gpio                                = gpio | 0x02;
    // store new gpio value into GPIO expander output register
    i2cWrite2Bfr[0]                     = 0x05;
    i2cWrite2Bfr[1]                     = gpio;
    rpio.i2cWrite(i2cWrite2Bfr);
    rpio.i2cEnd();
}

Comm.prototype.pwrmSwitch1              = function() {
    rpio.i2cBegin();
    rpio.i2cSetSlaveAddress(0x43);
    rpio.i2cSetBaudRate(100000);
    rpio.i2cSetClockDivider(2500);

    // read GPIO expander input register
    i2cWrite1Bfr[0]                     = 0x0f;
    rpio.i2cWrite(i2cWrite1Bfr);
    rpio.i2cRead(i2cRxBfr, 1);
    rpio.i2cEnd();

    return((i2cRxBfr[0] & 0x80) >> 7);
}

Comm.prototype.pwrmSwitch2              = function() {
    rpio.i2cBegin();
    rpio.i2cSetSlaveAddress(0x43);
    rpio.i2cSetBaudRate(100000);
    rpio.i2cSetClockDivider(2500);

    // read GPIO expander input register
    i2cWrite1Bfr[0]                     = 0x0f;
    rpio.i2cWrite(i2cWrite1Bfr);
    rpio.i2cRead(i2cRxBfr, 1);
    rpio.i2cEnd();

    return ((i2cRxBfr[0] & 0x40) >> 6);
}

Comm.prototype.pwrmPower5V0             = function() {
    rpio.i2cBegin();
    rpio.i2cSetSlaveAddress(0x41);
    rpio.i2cSetBaudRate(100000);
    rpio.i2cSetClockDivider(2500);
    // Initialize each INA226
    // write to config register addr 0x00 - 0x4737
    // - bits 9-11 = 011 = number of averages 64
    // - bits 6-8  = 101 = bus voltage conversion time 1.1 (mSec)
    // - bits 3-5  = 110 = shunt voltage conversion time 4.156 (mSec)
    // - bits 0-2  = 111 = shunt and bus continuous
    //   i2cWrite3Bfr[0]                     = 0x00;
    //   i2cWrite3Bfr[1]                     = 0x47;
    //   i2cWrite3Bfr[2]                     = 0x37;
    //   rpio.i2cWrite(i2cWrite2Bfr);

    i2cWrite1Bfr[0]                     = 0x02;
    rpio.i2cWrite(i2cWrite1Bfr);
    rpio.i2cRead(i2cRxBfr, 2);

    let voltage                         = ((i2cRxBfr[0] << 8) + i2cRxBfr[1]);
    voltage                         = (((voltage * 0.00125) / 1).toFixed(3));

    i2cWrite1Bfr[0]                     = 0x01;
    rpio.i2cWrite(i2cWrite1Bfr);
    rpio.i2cRead(i2cRxBfr, 2);
    rpio.i2cEnd();

    let current                         = ((i2cRxBfr[0] << 8) + i2cRxBfr[1]);
    if (current > 32000) {
        current                         = 0;
    }
    current                         = (((current * 0.0000025) / 0.2).toFixed(3));

    return ({ volts: voltage, amps: current});
}

Comm.prototype.pwrmPowerVo             = function() {
    rpio.i2cBegin();
    rpio.i2cSetSlaveAddress(0x40);
    rpio.i2cSetBaudRate(100000);
    rpio.i2cSetClockDivider(2500);
    // Initialize each INA226
    // write to config register addr 0x00 - 0x4737
    // - bits 9-11 = 011 = number of averages 64
    // - bits 6-8  = 101 = bus voltage conversion time 1.1 (mSec)
    // - bits 3-5  = 110 = shunt voltage conversion time 4.156 (mSec)
    // - bits 0-2  = 111 = shunt and bus continuous
    //   i2cWrite3Bfr[0]                     = 0x00;
    //   i2cWrite3Bfr[1]                     = 0x47;
    //   i2cWrite3Bfr[2]                     = 0x37;
    //   rpio.i2cWrite(i2cWrite2Bfr);

    i2cWrite1Bfr[0] = 0x02;
    rpio.i2cWrite(i2cWrite1Bfr);
    rpio.i2cRead(i2cRxBfr, 2);

    let voltage = ((i2cRxBfr[0] << 8) + i2cRxBfr[1]);
    voltage                         = (((voltage * 0.00125) / 1).toFixed(3));

    i2cWrite1Bfr[0]                     = 0x01;
    rpio.i2cWrite(i2cWrite1Bfr);
    rpio.i2cRead(i2cRxBfr, 2);
    rpio.i2cEnd();

    let current                         = ((i2cRxBfr[0] << 8) + i2cRxBfr[1]);
    if (current > 32000) {
        current                         = 0;
    }
    current                         = (((current * 0.0000025) / 0.2).toFixed(3));

    return ({volts: voltage, amps: current});
}


function _moduleAddr(addr) {
    if (addr < 16) {
        switch (addr) {
            case 0:
                rpio.open(16, rpio.OUTPUT, rpio.HIGH);
                rpio.open(18, rpio.OUTPUT, rpio.HIGH);
                rpio.open(29, rpio.OUTPUT, rpio.HIGH);
                rpio.open(31, rpio.OUTPUT, rpio.HIGH);
                break;
            case 1:
                rpio.open(16, rpio.OUTPUT, rpio.LOW);
                rpio.open(18, rpio.OUTPUT, rpio.HIGH);
                rpio.open(29, rpio.OUTPUT, rpio.HIGH);
                rpio.open(31, rpio.OUTPUT, rpio.HIGH);
                break;
            case 2:
                rpio.open(16, rpio.OUTPUT, rpio.HIGH);
                rpio.open(18, rpio.OUTPUT, rpio.LOW);
                rpio.open(29, rpio.OUTPUT, rpio.HIGH);
                rpio.open(31, rpio.OUTPUT, rpio.HIGH);
                break;
            case 3:
                rpio.open(16, rpio.OUTPUT, rpio.LOW);
                rpio.open(18, rpio.OUTPUT, rpio.LOW);
                rpio.open(29, rpio.OUTPUT, rpio.HIGH);
                rpio.open(31, rpio.OUTPUT, rpio.HIGH);
                break;
            case 4:
                rpio.open(16, rpio.OUTPUT, rpio.HIGH);
                rpio.open(18, rpio.OUTPUT, rpio.HIGH);
                rpio.open(29, rpio.OUTPUT, rpio.LOW);
                rpio.open(31, rpio.OUTPUT, rpio.HIGH);
                break;
            case 5:
                rpio.open(16, rpio.OUTPUT, rpio.LOW);
                rpio.open(18, rpio.OUTPUT, rpio.HIGH);
                rpio.open(29, rpio.OUTPUT, rpio.LOW);
                rpio.open(31, rpio.OUTPUT, rpio.HIGH);
                break;
            case 6:
                rpio.open(16, rpio.OUTPUT, rpio.HIGH);
                rpio.open(18, rpio.OUTPUT, rpio.LOW);
                rpio.open(29, rpio.OUTPUT, rpio.LOW);
                rpio.open(31, rpio.OUTPUT, rpio.HIGH);
                break;
            case 7:
                rpio.open(16, rpio.OUTPUT, rpio.LOW);
                rpio.open(18, rpio.OUTPUT, rpio.LOW);
                rpio.open(29, rpio.OUTPUT, rpio.LOW);
                rpio.open(31, rpio.OUTPUT, rpio.HIGH);
                break;
            case 8:
                rpio.open(16, rpio.OUTPUT, rpio.HIGH);
                rpio.open(18, rpio.OUTPUT, rpio.HIGH);
                rpio.open(29, rpio.OUTPUT, rpio.HIGH);
                rpio.open(31, rpio.OUTPUT, rpio.LOW);
                break;
            case 9:
                rpio.open(16, rpio.OUTPUT, rpio.LOW);
                rpio.open(18, rpio.OUTPUT, rpio.HIGH);
                rpio.open(29, rpio.OUTPUT, rpio.HIGH);
                rpio.open(31, rpio.OUTPUT, rpio.LOW);
                break;
            case 10:
                rpio.open(16, rpio.OUTPUT, rpio.HIGH);
                rpio.open(18, rpio.OUTPUT, rpio.LOW);
                rpio.open(29, rpio.OUTPUT, rpio.HIGH);
                rpio.open(31, rpio.OUTPUT, rpio.LOW);
                break;
            case 11:
                rpio.open(16, rpio.OUTPUT, rpio.LOW);
                rpio.open(18, rpio.OUTPUT, rpio.LOW);
                rpio.open(29, rpio.OUTPUT, rpio.HIGH);
                rpio.open(31, rpio.OUTPUT, rpio.LOW);
                break;
            case 12:
                rpio.open(16, rpio.OUTPUT, rpio.HIGH);
                rpio.open(18, rpio.OUTPUT, rpio.HIGH);
                rpio.open(29, rpio.OUTPUT, rpio.LOW);
                rpio.open(31, rpio.OUTPUT, rpio.LOW);
                break;
            case 13:
                rpio.open(16, rpio.OUTPUT, rpio.LOW);
                rpio.open(18, rpio.OUTPUT, rpio.HIGH);
                rpio.open(29, rpio.OUTPUT, rpio.LOW);
                rpio.open(31, rpio.OUTPUT, rpio.LOW);
                break;
            case 14:
                rpio.open(16, rpio.OUTPUT, rpio.HIGH);
                rpio.open(18, rpio.OUTPUT, rpio.LOW);
                rpio.open(29, rpio.OUTPUT, rpio.LOW);
                rpio.open(31, rpio.OUTPUT, rpio.LOW);
                break;
            case 15:
                rpio.open(16, rpio.OUTPUT, rpio.LOW);
                rpio.open(18, rpio.OUTPUT, rpio.LOW);
                rpio.open(29, rpio.OUTPUT, rpio.LOW);
                rpio.open(31, rpio.OUTPUT, rpio.LOW);
                break;
            default:
                break;
        }
    }

}


module.exports     